= Untangled Developer's Reference
:source-highlighter: coderay
:source-language: clojure

== Introduction

This reference guide is meant to be an indexed document for quickly finding information about the Untangled Web
Framework. If you're trying to learn Untangled, then you should do the
https://github.com/untangled-web/untangled-tutorial[tutorial].

== Basic UI

Untangled uses Om, which in turn uses https://facebook.github.io/react/index.html[React^] underneath.

=== Creating a Custom React Class

The mechanism for creating components is the `defui` macro:

[source]
----
(defui ComponentClassName
  Object
  (componentWillUpdate [this nextprops nextstate] (println "Component will update"))
  (render [this]
    (dom/div nil "Hello world")))
----

This macro generates a React class as a plain JavaScript class, so it is completely compatible with the
React ecosystem.

Notice the use of `Object`. It indicates that the following method bodies (like in 
http://clojure.org/reference/protocols[protocols^]) are being added to the
generated class. From an OO perspective, this is like saying \"my widget extends Object\". The `render`
method is the only method you need, but you can also add in your own methods or React lifecycle
methods.

=== React lifecycle methods

If you wish to provide 
https://facebook.github.io/react/docs/component-specs.html#lifecycle-methods[lifecycle methods^], you can
define them under the Object section of the UI:

[source]
----
(defui WidgetWithHook
  Object
  (componentWillUpdate [this nextprops nextstate] (println "Component will update"))
  (render [this]
    (dom/div nil "Hello world")))
----

==== Lifecycle method signatures

For reference these are the signatures you should use for the React Lifecycle methods:

[source]
----
(initLocalState [this])
(componentWillReceiveProps [this next-props])
(componentWillUpdate [this next-props next-state])
(componentDidUpdate [this prev-props prev-state])
(componentWillMount [this])
(componentDidMount [this])
(componentWillUnmount [this])
----

=== ClojureScript and React â€“ HTML differences

Here are some common things you'll want to know how to do that are different when rendering with Om/ClojureScript:

- Inline styles are specified with real maps `(dom/p #js { :style #js {:backgroundColor \"rgb(120,33,41)\"} } ...)`.
Note the nested use of raw Javascript maps. These are passed directly to React. Using cljs persistent data structures
won't work.
- CSS class names are specified with `:className` instead of `:class`.
- Any time there are adjacent elements of the same type in the DOM, they should each have a unique `:key`
attribute. This is typically generated by a function you supply to the Om factory function, but you can
also do it manually.

=== Element factory

In order to render components on the screen you need an element factory.
You generate a factory with `om/factory`, which will then
act like a new 'tag' for your DOM. We commonly prefix these factories with `ui-` so
we don't confuse them with query attribute names and other local bindings. If the 
component is ever to be rendered in a list of adjacent elements then the factory should
be given a key function for generating unique React keys on the component.

[source]
----
(def ui-widget (om/factory Widget {:keyfn (fn [props] (get props :some-prop))}))
----

=== Rendering a Component, Sending, and Accessing Properties

You can now render a widget inside of any other component using `(ui-widget { :prop 1 })`.

You access properties in a component using `om/props`:"

[source]
----
(defui Widget
  Object
  (render [this]
    (let [{:keys [name]} (om/props this)]
      (dom/div nil (str "Hello " name)))))

(def ui-widget (om/factory Widget))

...
   (ui-widget {:name "Sally"})
----

=== Computed data like Callbacks

In plain React you store component local state and pass data from the parent to the child through props.
You also pass your callbacks through props. In Untangled, we need a slight variation of
this because a component can have a query that asks the underlying system for data. 

If you complect callbacks and such with this queried data then you run into trouble because the rendering system
can re-render a component without going through the parent, meaning that callbacks could be lost.

So, in general *props are for passing data that the component requested from a query*.

As such, Om has an additional mechanism for passing things that were not specifically asked for in a query: Computed
properties.

For your Om UI to function properly you must attach computed properties to props via the helper function `om/computed`.
The child can look for these computed properties using `om/get-computed`.

=== Stateful components

Earlier we stress that your components should be stateless whenever possible. There are a few
notable exceptions that we have found useful (or even necessary):

- The Untangled support viewer shows each app state change. User input (each letter they type) can
be quite tedious to watch in a support viewer. Moving these kinds of interstitial form interactions
into local component state causes little harm, and greatly enhances support. Om automatically hooks up local
state to input fields when you use "uncontrolled" form elements (which means you didn't set value/checked).
- External library integration. We use stateful components like D3 visualizations.

==== Form inputs

Om already hooks local state to form elements. So, in fact, you have to override this to *not* use
component local state. For text controls we'd recommend you leave it this way. For other controls like
checkboxes it is probably best to override this.

==== External library state

See the D3 example in the Untangled Tutorial.

=== Built-in React DOM

All of the standard HTML tags have pre-built React components, accessible from the `om.dom` namespace.

[source]
----
(ns ui
  (:require [om.dom :as dom]))

(defui Widget
  Object
  (render [this]
    (dom/div nil (str "Hello " name))))
----

== Application Database Format

Untangled applications use the default Om database format. This is a simple graph database format made from
standard Clojurescript persistent data structures: Maps and vectors. The entire database is a map.

=== Tables

Specific items in the database are stored in tables. Each table is indexed by a top-level key in the database.
Items in the database can refer to other items via a foreign reference, which is formatted as an Ident. It is also legal
to have top-level data that is not a table.

[source]
----
{:value 53
 :table/by-id { 1 { :id 1 :x 1 } } }
----

The only way to tell a table from a value is by convention. Tables will usually be named in a way that
indicates what the primary key of the table is (e.g. `by-id`), and will be maps of maps. Regular values can
be anything, including an Ident.

=== Idents

An Ident is nothing more than a two element vector, where the first entry is a keyword (the "name" of a database table)
and the second entry is the ID of the object in that table: `[:table-name id]`

In the database above you would describe the object in the table as `[:table/by-id 1]`.

=== Graph

Combining regular values, tables, and idents gives you the overall database format which can support any arbitrary
graph. The database below has a list of two people (via idents pointing to the people in the table), and each
person has a pointer to the person that is their mate. This creates a graph with a loop (when following mate).

[source]
----
{:my-list [ [:people/by-id 1] [:people/by-id 2] ]
 :people/by-id { 
   1 { :db/id 1 :person/name "Tony" :person/mate [:people/by-id 2]} 
   2 { :db/id 2 :person/name "Jill" :person/mate [:people/by-id 1]}}}
----

[ditaa,target=basic-db]
....
                                                  +-------------+
                                                  |             |
                                           Table  v             |
 +-------+      +-----------------+       +----------------+    |
 |my-list|----->| :people/by-id 1 |------>| 1  Tony    mate|-+  |
 +-------+      +-----------------+       |                | |  |
                | :people/by-id 2 |------>| 2  Jill    mate|-+--+
                +-----------------+       +----------------+ |
                                                 ^           |
                                                 |           |
                                                 +-----------+
....

== The Query Language

The query language is a subset of Datomic Pull syntax. It is a syntax that is designed to walk a graph and produce a
tree (which is suitable for a UI, which is naturally a tree).

Queries are written as a vector.

=== Attributes

The query `[:a :b :c]` means read the attributes `:a` `:b`, and `:c` from the current object. For example,
if this query was against the root of the graph, it would mean the top-level database itself should contain the
keys `:a`, `:b`, and `:c`. In the context of a join (or sequence of joins) it indicates attribute reads in that
context.

One may query any attribute that makes sense, including an entire table. For example, the query `[:people/by-id]` 
against the database above will return:

[source]
----
{ :people/by-id { 1 { :db/id 1 :person/name "Tony" :person/mate [:people/by-id 2]} 
                  2 { :db/id 2 :person/name "Jill" :person/mate [:people/by-id 1]}}}
----

=== Joins

Joins can be done against reference typed attributes (which essentially means an attribute holding an ident).

Joins are written as a map, where the key is the join point, and the value is a sub-query: `[{:my-list [:name]}]`. If
the join point is a vector of idents, then it is a to-many join and the query will result in multiple values. If 
the join point is a single ident, then it is a to-one join, and the query will result in a single value. In the
context of our database above this query should return the names of the people in my list.

The join shown in the prior paragraph against our database above would result in:

[source]
----
{ :my-list [ {:name "Tony"} {:name "Jill"} ] }
----

=== Recursion

=== Unions

== Initial Application State

=== Using InitialAppState

=== Using a manually-constructed graph db

=== Using a manually-constructed tree

== Mutations

